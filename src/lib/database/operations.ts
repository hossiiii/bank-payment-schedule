import { 
  Bank, 
  Card, 
  Transaction,
  BankInput,
  CardInput,
  TransactionInput,
  TransactionFilters,
  BankTotal,
  MonthlySchedule,
  ScheduleItem,
  DatabaseOperationError,
  ValidationError,
  BankSchema,
  CardSchema,
  TransactionSchema,
  TransactionInputSchema,
  TransactionCreateSchema
} from '@/types/database';
import { getDatabase } from './schema';

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY = 100; // milliseconds

/**
 * Utility function to retry database operations
 */
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = MAX_RETRIES
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt === maxRetries) {
        throw new DatabaseOperationError(
          `Operation failed after ${maxRetries + 1} attempts`,
          lastError
        );
      }
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (attempt + 1)));
    }
  }
  
  throw lastError!;
}

/**
 * Bank operations
 */
export class BankOperations {
  private db = getDatabase();
  
  /**
   * Creates a new bank
   */
  async create(bankData: BankInput): Promise<Bank> {
    return withRetry(async () => {
      // Validate input
      const validatedData = BankSchema.omit({ id: true, createdAt: true }).parse(bankData);
      
      // Check for duplicate names
      const existing = await this.db.banks.where('name').equals(validatedData.name).first();
      if (existing) {
        throw new ValidationError(`Bank with name "${validatedData.name}" already exists`);
      }
      
      // Create bank with auto-generated id and timestamp
      const bank: Bank = {
        id: '', // Will be auto-generated by hook
        ...validatedData,
        createdAt: Date.now()
      };
      
      const id = await this.db.banks.add(bank);
      return await this.db.banks.get(id as string) as Bank;
    });
  }
  
  /**
   * Gets a bank by ID
   */
  async getById(id: string): Promise<Bank | undefined> {
    return withRetry(async () => {
      return await this.db.banks.get(id);
    });
  }
  
  /**
   * Gets all banks
   */
  async getAll(): Promise<Bank[]> {
    return withRetry(async () => {
      return await this.db.banks.orderBy('name').toArray();
    });
  }
  
  /**
   * Updates a bank
   */
  async update(id: string, updates: Partial<BankInput>): Promise<Bank> {
    return withRetry(async () => {
      const existing = await this.db.banks.get(id);
      if (!existing) {
        throw new ValidationError(`Bank with ID "${id}" not found`);
      }
      
      // Validate updates
      if (updates.name) {
        const duplicate = await this.db.banks
          .where('name').equals(updates.name)
          .and(bank => bank.id !== id)
          .first();
        if (duplicate) {
          throw new ValidationError(`Bank with name "${updates.name}" already exists`);
        }
      }
      
      await this.db.banks.update(id, updates);
      return await this.db.banks.get(id) as Bank;
    });
  }
  
  /**
   * Deletes a bank (with cascade check)
   */
  async delete(id: string): Promise<void> {
    return withRetry(async () => {
      // Check for dependent cards
      const dependentCards = await this.db.cards.where('bankId').equals(id).count();
      if (dependentCards > 0) {
        throw new ValidationError(
          `Cannot delete bank. ${dependentCards} cards are still using this bank.`
        );
      }
      
      // Check for dependent bank transactions
      const dependentBankTransactions = await this.db.transactions.where('bankId').equals(id).count();
      if (dependentBankTransactions > 0) {
        throw new ValidationError(
          `Cannot delete bank. ${dependentBankTransactions} direct bank transactions are still using this bank.`
        );
      }
      
      const deleted = await this.db.banks.delete(id);
      if (deleted === 0) {
        throw new ValidationError(`Bank with ID "${id}" not found`);
      }
    });
  }
  
  /**
   * Searches banks by name
   */
  async searchByName(query: string): Promise<Bank[]> {
    return withRetry(async () => {
      const lowercaseQuery = query.toLowerCase();
      return await this.db.banks
        .filter(bank => bank.name.toLowerCase().includes(lowercaseQuery))
        .toArray();
    });
  }
}

/**
 * Card operations
 */
export class CardOperations {
  private db = getDatabase();
  
  /**
   * Creates a new card
   */
  async create(cardData: CardInput): Promise<Card> {
    return withRetry(async () => {
      // Validate input
      const validatedData = CardSchema.omit({ id: true, createdAt: true }).parse(cardData);
      
      // Validate bank exists
      const bank = await this.db.banks.get(validatedData.bankId);
      if (!bank) {
        throw new ValidationError(`Bank with ID "${validatedData.bankId}" not found`);
      }
      
      // Check for duplicate names
      const existing = await this.db.cards.where('name').equals(validatedData.name).first();
      if (existing) {
        throw new ValidationError(`Card with name "${validatedData.name}" already exists`);
      }
      
      const card: Card = {
        id: '', // Will be auto-generated by hook
        ...validatedData,
        createdAt: Date.now()
      };
      
      const id = await this.db.cards.add(card);
      return await this.db.cards.get(id as string) as Card;
    });
  }
  
  /**
   * Gets a card by ID
   */
  async getById(id: string): Promise<Card | undefined> {
    return withRetry(async () => {
      return await this.db.cards.get(id);
    });
  }
  
  /**
   * Gets all cards
   */
  async getAll(): Promise<Card[]> {
    return withRetry(async () => {
      return await this.db.cards.orderBy('name').toArray();
    });
  }
  
  /**
   * Gets cards by bank ID
   */
  async getByBankId(bankId: string): Promise<Card[]> {
    return withRetry(async () => {
      return await this.db.cards.where('bankId').equals(bankId).toArray();
    });
  }
  
  /**
   * Updates a card
   */
  async update(id: string, updates: Partial<CardInput>): Promise<Card> {
    return withRetry(async () => {
      const existing = await this.db.cards.get(id);
      if (!existing) {
        throw new ValidationError(`Card with ID "${id}" not found`);
      }
      
      // Validate bank exists if being updated
      if (updates.bankId) {
        const bank = await this.db.banks.get(updates.bankId);
        if (!bank) {
          throw new ValidationError(`Bank with ID "${updates.bankId}" not found`);
        }
      }
      
      // Validate name uniqueness if being updated
      if (updates.name) {
        const duplicate = await this.db.cards
          .where('name').equals(updates.name)
          .and(card => card.id !== id)
          .first();
        if (duplicate) {
          throw new ValidationError(`Card with name "${updates.name}" already exists`);
        }
      }
      
      await this.db.cards.update(id, updates);
      return await this.db.cards.get(id) as Card;
    });
  }
  
  /**
   * Deletes a card (with cascade check)
   */
  async delete(id: string): Promise<void> {
    return withRetry(async () => {
      // Check for dependent transactions
      const dependentTransactions = await this.db.transactions.where('cardId').equals(id).count();
      if (dependentTransactions > 0) {
        throw new ValidationError(
          `Cannot delete card. ${dependentTransactions} transactions are still using this card.`
        );
      }
      
      const deleted = await this.db.cards.delete(id);
      if (deleted === 0) {
        throw new ValidationError(`Card with ID "${id}" not found`);
      }
    });
  }
}

/**
 * Transaction operations
 */
export class TransactionOperations {
  private db = getDatabase();
  
  /**
   * Creates a new transaction
   */
  async create(transactionData: TransactionInput): Promise<Transaction> {
    return withRetry(async () => {
      // Validate input (without scheduledPayDate as it will be calculated)
      const validatedData = TransactionInputSchema.parse(transactionData);
      
      let scheduledPayDate: number;
      
      // Calculate or use provided scheduled payment date
      if (validatedData.scheduledPayDate && validatedData.isScheduleEditable) {
        // Use manually edited scheduled payment date
        scheduledPayDate = validatedData.scheduledPayDate;
      } else if (validatedData.paymentType === 'card') {
        // Calculate based on card settings
        const card = await this.db.cards.get(validatedData.cardId!);
        if (!card) {
          throw new ValidationError(`Card with ID "${validatedData.cardId}" not found`);
        }
        
        const { calculateCardPaymentDate } = await import('@/lib/utils/paymentCalc');
        const transactionDate = new Date(validatedData.date);
        const paymentResult = calculateCardPaymentDate(transactionDate, card);
        scheduledPayDate = paymentResult.scheduledPayDate.getTime();
      } else {
        // Bank payment - calculate based on transaction date
        const { calculateBankPaymentDate } = await import('@/lib/utils/paymentCalc');
        const transactionDate = new Date(validatedData.date);
        const paymentResult = calculateBankPaymentDate(transactionDate, true);
        scheduledPayDate = paymentResult.scheduledPayDate.getTime();
        
        // Validate bank exists
        const bank = await this.db.banks.get(validatedData.bankId!);
        if (!bank) {
          throw new ValidationError(`Bank with ID "${validatedData.bankId}" not found`);
        }
      }
      
      const transactionToCreate = {
        ...validatedData,
        scheduledPayDate,
        createdAt: Date.now()
      };
      
      // Validate the complete transaction data with calculated fields
      const validatedTransaction = TransactionCreateSchema.parse(transactionToCreate);
      
      const transaction: Transaction = {
        id: '', // Will be auto-generated by hook
        ...validatedTransaction
      };
      
      const id = await this.db.transactions.add(transaction);
      return await this.db.transactions.get(id as string) as Transaction;
    });
  }
  
  /**
   * Gets a transaction by ID
   */
  async getById(id: string): Promise<Transaction | undefined> {
    return withRetry(async () => {
      return await this.db.transactions.get(id);
    });
  }
  
  /**
   * Gets transactions with filters
   */
  async getFiltered(filters: TransactionFilters = {}): Promise<Transaction[]> {
    return withRetry(async () => {
      let query = this.db.transactions.toCollection();
      
      // Apply filters
      if (filters.dateRange) {
        query = query.filter(tx => 
          tx.date >= filters.dateRange!.start && tx.date <= filters.dateRange!.end
        );
      }
      
      if (filters.bankId) {
        // For bank filter, we need to include both direct bank transactions and card transactions from that bank
        // Note: This is a simplified filter - for complex queries we might need to do a join operation
        query = query.filter(tx => 
          tx.bankId === filters.bankId
        );
      }
      
      if (filters.cardId) {
        query = query.filter(tx => tx.cardId === filters.cardId);
      }
      
      if (filters.paymentType) {
        query = query.filter(tx => tx.paymentType === filters.paymentType);
      }
      
      if (filters.minAmount !== undefined) {
        query = query.filter(tx => tx.amount >= filters.minAmount!);
      }
      
      if (filters.maxAmount !== undefined) {
        query = query.filter(tx => tx.amount <= filters.maxAmount!);
      }
      
      return await query.sortBy('date');
    });
  }
  
  /**
   * Gets transactions for a specific month's scheduled payments
   */
  async getScheduledForMonth(year: number, month: number): Promise<Transaction[]> {
    try {
      const startOfMonth = new Date(year, month - 1, 1).getTime();
      const endOfMonth = new Date(year, month, 0, 23, 59, 59).getTime();
      
      const result = await this.db.transactions
        .where('scheduledPayDate')
        .between(startOfMonth, endOfMonth, true, true)
        .sortBy('scheduledPayDate');
        
      return result;
    } catch (error) {
      console.error(`Error in getScheduledForMonth(${year}, ${month}):`, error);
      throw error;
    }
  }
  
  /**
   * Gets monthly payment schedule with bank totals
   */
  async getMonthlySchedule(year: number, month: number): Promise<MonthlySchedule> {
    return withRetry(async () => {
      const transactions = await this.getScheduledForMonth(year, month);
      
      // Get related cards first
      const cardIds = [...new Set(transactions.map(tx => tx.cardId).filter(Boolean))];
      const cards = await Promise.all(cardIds.map(id => this.db.cards.get(id!)));
      const cardsMap = new Map(cards.filter(Boolean).map(card => [card!.id, card!]));
      
      // Get all bank IDs from both card transactions and direct bank transactions
      const bankIdsFromCards = cards.filter(Boolean).map(card => card!.bankId);
      const bankIdsFromTransactions = transactions.map(tx => tx.bankId).filter(Boolean);
      const allBankIds = [...new Set([...bankIdsFromCards, ...bankIdsFromTransactions])];
      
      const banks = await Promise.all(allBankIds.map(id => this.db.banks.get(id!)));
      const banksMap = new Map(banks.filter(Boolean).map(bank => [bank!.id, bank!]));
      
      // Create schedule items
      const items: ScheduleItem[] = transactions.map(tx => {
        let bankName = 'Unknown Bank';
        let cardName: string | undefined;
        
        if (tx.paymentType === 'card' && tx.cardId) {
          const card = cardsMap.get(tx.cardId);
          if (card) {
            const bank = banksMap.get(card.bankId);
            bankName = bank?.name || `Unknown Bank (Card Bank ID: ${card.bankId})`;
            cardName = card.name;
          }
        } else if (tx.paymentType === 'bank' && tx.bankId) {
          const bank = banksMap.get(tx.bankId);
          if (!bank) {
            console.warn(`Bank not found for transaction ID: ${tx.id}, bankId: ${tx.bankId}`);
            console.warn('Available banks:', Array.from(banksMap.keys()));
          }
          bankName = bank?.name || `Unknown Bank (ID: ${tx.bankId})`;
        }
        
        return {
          transactionId: tx.id,
          date: new Date(tx.scheduledPayDate),
          bankName,
          storeName: tx.storeName,
          usage: tx.usage,
          amount: tx.amount,
          paymentType: tx.paymentType,
          cardName,
          isScheduleEditable: tx.isScheduleEditable
        };
      });
      
      // Calculate bank totals
      const bankTotalsMap = new Map<string, BankTotal>();
      
      transactions.forEach(tx => {
        let bankId: string | undefined;
        let bankName: string | undefined;
        
        if (tx.paymentType === 'card' && tx.cardId) {
          const card = cardsMap.get(tx.cardId);
          if (card) {
            bankId = card.bankId;
            bankName = banksMap.get(card.bankId)?.name;
          }
        } else if (tx.paymentType === 'bank' && tx.bankId) {
          bankId = tx.bankId;
          bankName = banksMap.get(tx.bankId)?.name;
        }
        
        if (!bankId || !bankName) return;
        
        const current = bankTotalsMap.get(bankId) || {
          bankId,
          bankName,
          totalAmount: 0,
          transactionCount: 0
        };
        
        current.totalAmount += tx.amount;
        current.transactionCount += 1;
        
        bankTotalsMap.set(bankId, current);
      });
      
      const bankTotals = Array.from(bankTotalsMap.values());
      const monthTotal = bankTotals.reduce((sum, bank) => sum + bank.totalAmount, 0);
      
      return {
        year,
        month,
        items,
        bankTotals,
        monthTotal,
        totalAmount: monthTotal,
        totalTransactions: items.length
      };
    });
  }
  
  /**
   * Updates a transaction
   */
  async update(id: string, updates: Partial<TransactionInput>): Promise<Transaction> {
    return withRetry(async () => {
      const existing = await this.db.transactions.get(id);
      if (!existing) {
        throw new ValidationError(`Transaction with ID "${id}" not found`);
      }
      
      // Validate references if being updated
      if (updates.paymentType === 'bank' && updates.bankId) {
        const bank = await this.db.banks.get(updates.bankId);
        if (!bank) {
          throw new ValidationError(`Bank with ID "${updates.bankId}" not found`);
        }
      }
      
      if (updates.paymentType === 'card' && updates.cardId) {
        const card = await this.db.cards.get(updates.cardId);
        if (!card) {
          throw new ValidationError(`Card with ID "${updates.cardId}" not found`);
        }
      }
      
      // Recalculate scheduled payment date if payment method changes and not manually edited
      if (updates.paymentType && !updates.isScheduleEditable) {
        const { calculateCardPaymentDate, calculateBankPaymentDate } = await import('@/lib/utils/paymentCalc');
        const transactionDate = new Date(updates.date || existing.date);
        
        if (updates.paymentType === 'card' && updates.cardId) {
          const card = await this.db.cards.get(updates.cardId);
          if (card) {
            const result = calculateCardPaymentDate(transactionDate, card);
            updates.scheduledPayDate = result.scheduledPayDate.getTime();
          }
        } else if (updates.paymentType === 'bank') {
          const result = calculateBankPaymentDate(transactionDate, true);
          updates.scheduledPayDate = result.scheduledPayDate.getTime();
        }
      }
      
      await this.db.transactions.update(id, updates);
      return await this.db.transactions.get(id) as Transaction;
    });
  }
  
  /**
   * Deletes a transaction
   */
  async delete(id: string): Promise<void> {
    return withRetry(async () => {
      const deleted = await this.db.transactions.delete(id);
      if (deleted === 0) {
        throw new ValidationError(`Transaction with ID "${id}" not found`);
      }
    });
  }
  
  /**
   * Bulk updates scheduled payment dates for card transactions
   */
  async updateScheduledPayDatesForCard(cardId: string, newDates: Record<string, number>): Promise<void> {
    return withRetry(async () => {
      const updates = Object.entries(newDates).map(([transactionId, scheduledPayDate]) => ({
        key: transactionId,
        changes: { scheduledPayDate }
      }));
      
      await this.db.transactions.bulkUpdate(updates);
    });
  }
}

// Export singleton instances
export const bankOperations = new BankOperations();
export const cardOperations = new CardOperations();
export const transactionOperations = new TransactionOperations();