import { 
  Bank, 
  Card, 
  Transaction,
  BankInput,
  CardInput,
  TransactionInput,
  TransactionFilters,
  BankTotal,
  MonthlySchedule,
  ScheduleItem,
  DatabaseOperationError,
  ValidationError,
  BankSchema,
  CardSchema,
  TransactionSchema,
  TransactionInputSchema,
  TransactionCreateSchema
} from '@/types/database';
import { getDatabase } from './schema';

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY = 100; // milliseconds

/**
 * Utility function to retry database operations
 */
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = MAX_RETRIES
): Promise<T> {
  let lastError: Error;
  
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      if (attempt === maxRetries) {
        throw new DatabaseOperationError(
          `Operation failed after ${maxRetries + 1} attempts`,
          lastError
        );
      }
      
      // Wait before retrying
      await new Promise(resolve => setTimeout(resolve, RETRY_DELAY * (attempt + 1)));
    }
  }
  
  throw lastError!;
}

/**
 * Bank operations
 */
export class BankOperations {
  private db = getDatabase();
  
  /**
   * Creates a new bank
   */
  async create(bankData: BankInput): Promise<Bank> {
    return withRetry(async () => {
      // Validate input
      const validatedData = BankSchema.omit({ id: true, createdAt: true }).parse(bankData);
      
      // Check for duplicate names
      const existing = await this.db.banks.where('name').equals(validatedData.name).first();
      if (existing) {
        throw new ValidationError(`Bank with name "${validatedData.name}" already exists`);
      }
      
      // Create bank with auto-generated id and timestamp
      const bank: Bank = {
        id: '', // Will be auto-generated by hook
        ...validatedData,
        createdAt: Date.now()
      };
      
      const id = await this.db.banks.add(bank);
      return await this.db.banks.get(id as string) as Bank;
    });
  }
  
  /**
   * Gets a bank by ID
   */
  async getById(id: string): Promise<Bank | undefined> {
    return withRetry(async () => {
      return await this.db.banks.get(id);
    });
  }
  
  /**
   * Gets all banks
   */
  async getAll(): Promise<Bank[]> {
    return withRetry(async () => {
      return await this.db.banks.orderBy('name').toArray();
    });
  }
  
  /**
   * Updates a bank
   */
  async update(id: string, updates: Partial<BankInput>): Promise<Bank> {
    return withRetry(async () => {
      const existing = await this.db.banks.get(id);
      if (!existing) {
        throw new ValidationError(`Bank with ID "${id}" not found`);
      }
      
      // Validate updates
      if (updates.name) {
        const duplicate = await this.db.banks
          .where('name').equals(updates.name)
          .and(bank => bank.id !== id)
          .first();
        if (duplicate) {
          throw new ValidationError(`Bank with name "${updates.name}" already exists`);
        }
      }
      
      await this.db.banks.update(id, updates);
      return await this.db.banks.get(id) as Bank;
    });
  }
  
  /**
   * Deletes a bank (with cascade check)
   */
  async delete(id: string): Promise<void> {
    return withRetry(async () => {
      // Check for dependent cards
      const dependentCards = await this.db.cards.where('bankId').equals(id).count();
      if (dependentCards > 0) {
        throw new ValidationError(
          `Cannot delete bank. ${dependentCards} cards are still using this bank.`
        );
      }
      
      // Check for dependent transactions
      const dependentTransactions = await this.db.transactions.where('bankId').equals(id).count();
      if (dependentTransactions > 0) {
        throw new ValidationError(
          `Cannot delete bank. ${dependentTransactions} transactions are still using this bank.`
        );
      }
      
      const deleted = await this.db.banks.delete(id);
      if (deleted === 0) {
        throw new ValidationError(`Bank with ID "${id}" not found`);
      }
    });
  }
  
  /**
   * Searches banks by name
   */
  async searchByName(query: string): Promise<Bank[]> {
    return withRetry(async () => {
      const lowercaseQuery = query.toLowerCase();
      return await this.db.banks
        .filter(bank => bank.name.toLowerCase().includes(lowercaseQuery))
        .toArray();
    });
  }
}

/**
 * Card operations
 */
export class CardOperations {
  private db = getDatabase();
  
  /**
   * Creates a new card
   */
  async create(cardData: CardInput): Promise<Card> {
    return withRetry(async () => {
      // Validate input
      const validatedData = CardSchema.omit({ id: true, createdAt: true }).parse(cardData);
      
      // Validate bank exists
      const bank = await this.db.banks.get(validatedData.bankId);
      if (!bank) {
        throw new ValidationError(`Bank with ID "${validatedData.bankId}" not found`);
      }
      
      // Check for duplicate names
      const existing = await this.db.cards.where('name').equals(validatedData.name).first();
      if (existing) {
        throw new ValidationError(`Card with name "${validatedData.name}" already exists`);
      }
      
      const card: Card = {
        id: '', // Will be auto-generated by hook
        ...validatedData,
        createdAt: Date.now()
      };
      
      const id = await this.db.cards.add(card);
      return await this.db.cards.get(id as string) as Card;
    });
  }
  
  /**
   * Gets a card by ID
   */
  async getById(id: string): Promise<Card | undefined> {
    return withRetry(async () => {
      return await this.db.cards.get(id);
    });
  }
  
  /**
   * Gets all cards
   */
  async getAll(): Promise<Card[]> {
    return withRetry(async () => {
      return await this.db.cards.orderBy('name').toArray();
    });
  }
  
  /**
   * Gets cards by bank ID
   */
  async getByBankId(bankId: string): Promise<Card[]> {
    return withRetry(async () => {
      return await this.db.cards.where('bankId').equals(bankId).toArray();
    });
  }
  
  /**
   * Updates a card
   */
  async update(id: string, updates: Partial<CardInput>): Promise<Card> {
    return withRetry(async () => {
      const existing = await this.db.cards.get(id);
      if (!existing) {
        throw new ValidationError(`Card with ID "${id}" not found`);
      }
      
      // Validate bank exists if being updated
      if (updates.bankId) {
        const bank = await this.db.banks.get(updates.bankId);
        if (!bank) {
          throw new ValidationError(`Bank with ID "${updates.bankId}" not found`);
        }
      }
      
      // Validate name uniqueness if being updated
      if (updates.name) {
        const duplicate = await this.db.cards
          .where('name').equals(updates.name)
          .and(card => card.id !== id)
          .first();
        if (duplicate) {
          throw new ValidationError(`Card with name "${updates.name}" already exists`);
        }
      }
      
      await this.db.cards.update(id, updates);
      return await this.db.cards.get(id) as Card;
    });
  }
  
  /**
   * Deletes a card (with cascade check)
   */
  async delete(id: string): Promise<void> {
    return withRetry(async () => {
      // Check for dependent transactions
      const dependentTransactions = await this.db.transactions.where('cardId').equals(id).count();
      if (dependentTransactions > 0) {
        throw new ValidationError(
          `Cannot delete card. ${dependentTransactions} transactions are still using this card.`
        );
      }
      
      const deleted = await this.db.cards.delete(id);
      if (deleted === 0) {
        throw new ValidationError(`Card with ID "${id}" not found`);
      }
    });
  }
}

/**
 * Transaction operations
 */
export class TransactionOperations {
  private db = getDatabase();
  
  /**
   * Creates a new transaction
   */
  async create(transactionData: TransactionInput): Promise<Transaction> {
    return withRetry(async () => {
      // Validate input (without scheduledPayDate as it will be calculated)
      const validatedData = TransactionInputSchema.parse(transactionData);
      
      // Get card information for payment calculation
      const card = await this.db.cards.get(validatedData.cardId);
      if (!card) {
        throw new ValidationError(`Card with ID "${validatedData.cardId}" not found`);
      }
      
      // Calculate scheduled payment date
      const { calculateCardPaymentDate } = await import('@/lib/utils/paymentCalc');
      const transactionDate = new Date(validatedData.date);
      const paymentResult = calculateCardPaymentDate(transactionDate, card);
      
      const transactionToCreate = {
        ...validatedData,
        scheduledPayDate: paymentResult.scheduledPayDate.getTime(),
        createdAt: Date.now()
      };
      
      // Validate the complete transaction data with calculated fields
      const validatedTransaction = TransactionCreateSchema.parse(transactionToCreate);
      
      const transaction: Transaction = {
        id: '', // Will be auto-generated by hook
        ...validatedTransaction
      };
      
      const id = await this.db.transactions.add(transaction);
      return await this.db.transactions.get(id as string) as Transaction;
    });
  }
  
  /**
   * Gets a transaction by ID
   */
  async getById(id: string): Promise<Transaction | undefined> {
    return withRetry(async () => {
      return await this.db.transactions.get(id);
    });
  }
  
  /**
   * Gets transactions with filters
   */
  async getFiltered(filters: TransactionFilters = {}): Promise<Transaction[]> {
    return withRetry(async () => {
      let query = this.db.transactions.toCollection();
      
      // Apply filters
      if (filters.dateRange) {
        query = query.filter(tx => 
          tx.date >= filters.dateRange!.start && tx.date <= filters.dateRange!.end
        );
      }
      
      if (filters.bankId) {
        query = query.filter(tx => tx.bankId === filters.bankId);
      }
      
      if (filters.cardId) {
        query = query.filter(tx => tx.cardId === filters.cardId);
      }
      
      if (filters.methodType) {
        query = query.filter(tx => tx.methodType === filters.methodType);
      }
      
      if (filters.minAmount !== undefined) {
        query = query.filter(tx => tx.amount >= filters.minAmount!);
      }
      
      if (filters.maxAmount !== undefined) {
        query = query.filter(tx => tx.amount <= filters.maxAmount!);
      }
      
      return await query.sortBy('date');
    });
  }
  
  /**
   * Gets transactions for a specific month's scheduled payments
   */
  async getScheduledForMonth(year: number, month: number): Promise<Transaction[]> {
    try {
      const startOfMonth = new Date(year, month - 1, 1).getTime();
      const endOfMonth = new Date(year, month, 0, 23, 59, 59).getTime();
      
      const result = await this.db.transactions
        .where('scheduledPayDate')
        .between(startOfMonth, endOfMonth, true, true)
        .sortBy('scheduledPayDate');
        
      return result;
    } catch (error) {
      console.error(`Error in getScheduledForMonth(${year}, ${month}):`, error);
      throw error;
    }
  }
  
  /**
   * Gets monthly payment schedule with bank totals
   */
  async getMonthlySchedule(year: number, month: number): Promise<MonthlySchedule> {
    return withRetry(async () => {
      const transactions = await this.getScheduledForMonth(year, month);
      
      // Get related cards first
      const cardIds = [...new Set(transactions.map(tx => tx.cardId).filter(Boolean))];
      const cards = await Promise.all(cardIds.map(id => this.db.cards.get(id!)));
      const cardsMap = new Map(cards.filter(Boolean).map(card => [card!.id, card!]));
      
      // Then get related banks from cards
      const bankIds = [...new Set(cards.filter(Boolean).map(card => card!.bankId))];
      const banks = await Promise.all(bankIds.map(id => this.db.banks.get(id)));
      
      const banksMap = new Map(banks.filter(Boolean).map(bank => [bank!.id, bank!]));
      
      // Create schedule items
      const items: ScheduleItem[] = transactions.map(tx => ({
        transactionId: tx.id,
        date: new Date(tx.scheduledPayDate),
        bankName: banksMap.get(cardsMap.get(tx.cardId)?.bankId!)?.name || 'Unknown Bank',
        storeName: tx.storeName,
        usage: tx.usage,
        amount: tx.amount,
        methodType: 'card' as const, // All transactions are card transactions
        cardName: tx.cardId ? cardsMap.get(tx.cardId)?.name : undefined
      }));
      
      // Calculate bank totals
      const bankTotalsMap = new Map<string, BankTotal>();
      
      transactions.forEach(tx => {
        if (!tx.cardId) return;
        
        const card = cardsMap.get(tx.cardId);
        if (!card) return;
        
        const bank = banksMap.get(card.bankId);
        if (!bank) return;
        
        const current = bankTotalsMap.get(card.bankId) || {
          bankId: card.bankId,
          bankName: bank.name,
          totalAmount: 0,
          transactionCount: 0
        };
        
        current.totalAmount += tx.amount;
        current.transactionCount += 1;
        
        bankTotalsMap.set(card.bankId, current);
      });
      
      const bankTotals = Array.from(bankTotalsMap.values());
      const monthTotal = bankTotals.reduce((sum, bank) => sum + bank.totalAmount, 0);
      
      return {
        year,
        month,
        items,
        bankTotals,
        monthTotal,
        totalAmount: monthTotal,
        totalTransactions: items.length
      };
    });
  }
  
  /**
   * Updates a transaction
   */
  async update(id: string, updates: Partial<TransactionInput>): Promise<Transaction> {
    return withRetry(async () => {
      const existing = await this.db.transactions.get(id);
      if (!existing) {
        throw new ValidationError(`Transaction with ID "${id}" not found`);
      }
      
      // Validate references if being updated
      if (updates.bankId) {
        const bank = await this.db.banks.get(updates.bankId);
        if (!bank) {
          throw new ValidationError(`Bank with ID "${updates.bankId}" not found`);
        }
      }
      
      if (updates.cardId) {
        const card = await this.db.cards.get(updates.cardId);
        if (!card) {
          throw new ValidationError(`Card with ID "${updates.cardId}" not found`);
        }
      }
      
      await this.db.transactions.update(id, updates);
      return await this.db.transactions.get(id) as Transaction;
    });
  }
  
  /**
   * Deletes a transaction
   */
  async delete(id: string): Promise<void> {
    return withRetry(async () => {
      const deleted = await this.db.transactions.delete(id);
      if (deleted === 0) {
        throw new ValidationError(`Transaction with ID "${id}" not found`);
      }
    });
  }
  
  /**
   * Bulk updates scheduled payment dates for card transactions
   */
  async updateScheduledPayDatesForCard(cardId: string, newDates: Record<string, number>): Promise<void> {
    return withRetry(async () => {
      const updates = Object.entries(newDates).map(([transactionId, scheduledPayDate]) => ({
        key: transactionId,
        changes: { scheduledPayDate }
      }));
      
      await this.db.transactions.bulkUpdate(updates);
    });
  }
}

// Export singleton instances
export const bankOperations = new BankOperations();
export const cardOperations = new CardOperations();
export const transactionOperations = new TransactionOperations();